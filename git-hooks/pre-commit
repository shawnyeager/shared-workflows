#!/bin/bash

# Pre-commit hook to auto-fix markdown issues
# 1. Uses markdownlint-cli2 --fix for standard formatting (respects .markdownlint.json)
# 2. Custom smart punctuation cleanup (markdownlint doesn't handle this)

set -e

# Check if there are any staged markdown files
STAGED_MD_FILES=$(git diff --cached --name-only --diff-filter=ACM | grep '\.md$' || true)

if [ -z "$STAGED_MD_FILES" ]; then
  exit 0
fi

echo ""
echo "üîç Auto-fixing markdown issues in staged files..."
echo ""

FIXED=false

# Step 1: Run markdownlint-cli2 --fix on staged files
# This respects .markdownlint.json and fixes:
# - MD009: Trailing spaces
# - MD010: Hard tabs
# - MD012: Multiple blank lines
# - MD018/019: Heading spacing
# - MD023: Indented headings
# - MD047: Missing trailing newline
# - Plus 25+ other fixable rules
if ! command -v markdownlint-cli2 &> /dev/null; then
  echo ""
  echo "‚ùå ERROR: markdownlint-cli2 not installed!"
  echo ""
  echo "   Install with: npm install -g markdownlint-cli2"
  echo "   Or run setup: ./scripts/setup.sh"
  echo ""
  exit 1
fi

echo "   üìã Running markdownlint-cli2 --fix..."
for file in $STAGED_MD_FILES; do
    # Skip CLAUDE.md and README.md (same as GitHub Action)
    if [[ "$file" == "CLAUDE.md" || "$file" == "README.md" ]]; then
      continue
    fi

    if [ -f "$file" ]; then
      # Run markdownlint with --fix, suppress output unless there are unfixable errors
      if markdownlint-cli2 --fix "$file" 2>&1 | grep -v "^markdownlint-cli2" | grep -v "^Finding:" | grep -v "^Linting:" | grep -v "^Summary: 0 error"; then
        FIXED=true
      fi
    fi
  done
echo ""

# Step 2: Fix smart punctuation (markdownlint doesn't have rules for this)
# Note: Skip YAML frontmatter (Hugo doesn't process markdown in frontmatter)
echo "   ‚ú® Fixing smart punctuation..."
for file in $STAGED_MD_FILES; do
  # Skip CLAUDE.md and README.md (same as GitHub Action)
  if [[ "$file" == "CLAUDE.md" || "$file" == "README.md" ]]; then
    continue
  fi

  if [ ! -f "$file" ]; then
    continue
  fi

  # Create temp file for processing
  TEMP_FILE=$(mktemp)

  # Extract frontmatter and body separately using awk
  awk '
    BEGIN { in_frontmatter=0; frontmatter_count=0; body_start=0 }
    /^---$/ {
      frontmatter_count++
      if (frontmatter_count == 1) { in_frontmatter=1; print; next }
      if (frontmatter_count == 2) { in_frontmatter=0; body_start=NR; print; next }
    }
    in_frontmatter || frontmatter_count < 2 { print; next }
    { print "BODY_START"; print; exit }
  ' "$file" > "$TEMP_FILE.frontmatter"

  # Extract body content (everything after second ---)
  awk '
    BEGIN { frontmatter_count=0 }
    /^---$/ { frontmatter_count++; if (frontmatter_count == 2) next; if (frontmatter_count < 2) next }
    frontmatter_count >= 2 { print }
  ' "$file" > "$TEMP_FILE.body"

  # Check if body has smart punctuation to fix
  CHANGES=false

  # Fix smart punctuation in body only
  if grep -q $'\xe2\x80\x99' "$TEMP_FILE.body"; then
    sed -i 's/\xe2\x80\x99/'\''/g' "$TEMP_FILE.body"
    echo "      ‚úèÔ∏è  $file: Fixed curly apostrophes (') ‚Üí (') [body only]"
    CHANGES=true
  fi

  if grep -q $'\xe2\x80\x98' "$TEMP_FILE.body"; then
    sed -i 's/\xe2\x80\x98/'\''/g' "$TEMP_FILE.body"
    echo "      ‚úèÔ∏è  $file: Fixed curly left quotes (') ‚Üí (') [body only]"
    CHANGES=true
  fi

  if grep -q $'\xe2\x80\x9c' "$TEMP_FILE.body"; then
    sed -i 's/\xe2\x80\x9c/"/g' "$TEMP_FILE.body"
    echo "      ‚úèÔ∏è  $file: Fixed curly left quotes (\") ‚Üí (\") [body only]"
    CHANGES=true
  fi

  if grep -q $'\xe2\x80\x9d' "$TEMP_FILE.body"; then
    sed -i 's/\xe2\x80\x9d/"/g' "$TEMP_FILE.body"
    echo "      ‚úèÔ∏è  $file: Fixed curly right quotes (\") ‚Üí (\") [body only]"
    CHANGES=true
  fi

  if grep -q $'\xe2\x80\x94' "$TEMP_FILE.body"; then
    sed -i 's/\xe2\x80\x94/---/g' "$TEMP_FILE.body"
    echo "      ‚úèÔ∏è  $file: Fixed em dashes (‚Äî) ‚Üí (---) [body only]"
    CHANGES=true
  fi

  if grep -q $'\xe2\x80\x93' "$TEMP_FILE.body"; then
    sed -i 's/\xe2\x80\x93/--/g' "$TEMP_FILE.body"
    echo "      ‚úèÔ∏è  $file: Fixed en dashes (‚Äì) ‚Üí (--) [body only]"
    CHANGES=true
  fi

  if grep -q $'\xe2\x80\xa6' "$TEMP_FILE.body"; then
    sed -i 's/\xe2\x80\xa6/.../g' "$TEMP_FILE.body"
    echo "      ‚úèÔ∏è  $file: Fixed ellipsis (‚Ä¶) ‚Üí (...) [body only]"
    CHANGES=true
  fi

  # If changes were made, recombine frontmatter and fixed body
  if [ "$CHANGES" = true ]; then
    # Remove the BODY_START marker if present
    sed -i '/^BODY_START$/d' "$TEMP_FILE.frontmatter"

    # Combine frontmatter and fixed body
    cat "$TEMP_FILE.frontmatter" "$TEMP_FILE.body" > "$file"
    FIXED=true
  fi

  # Clean up temp files
  rm -f "$TEMP_FILE" "$TEMP_FILE.frontmatter" "$TEMP_FILE.body"
done

# Re-stage all fixed files
if [ "$FIXED" = true ]; then
  for file in $STAGED_MD_FILES; do
    if [ -f "$file" ]; then
      git add "$file"
    fi
  done
  echo ""
  echo "‚úÖ Auto-fixed markdown issues. Changes have been staged."
  echo ""
fi

# Step 3: Validate go.mod has theme requirement (prevents hugo.work footgun)
# Check if go.mod is being committed
if git diff --cached --name-only | grep -q "^go.mod$"; then
  echo ""
  echo "üîç Validating Hugo module configuration..."
  echo ""

   if ! grep -q "require github.com/shawnyeager/tangerine-theme" go.mod; then
     echo ""
     echo "‚ùå ERROR: go.mod is missing theme require statement!"
     echo ""
     echo "   This is required for Netlify builds. The hugo.work file makes it"
     echo "   redundant locally, but production needs the explicit requirement."
     echo ""
     echo "   Fix with:"
     echo "   hugo mod get github.com/shawnyeager/tangerine-theme@latest"
     echo ""
     exit 1
   fi

  echo "   ‚úÖ Hugo module configuration valid"
  echo ""
fi

exit 0
